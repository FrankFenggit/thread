[TOC]



# C++11的多线程类thread

C++11之前，C++库中没有提供和线程相关的类或者接口，因此在编写多线程程序时，Windows上需要调用CreateThread创建线程，Linux下需要调用clone或者pthread线程库的接口函数pthread_create来创建线程。但是这样是直接调用了系统相关的API函数，编写的代码，无法做到跨平台编译运行。

[](test01.cpp)

# 线程互斥

在多线程环境中运行的代码段，需要考虑是否存在**竞态条件**，如果存在竞态条件，我们就说该代码段**不是线程安全的**，不能直接运行在多线程环境当中，对于这样的代码段，我们经常称之为**临界区资源**，对于临界区资源，多线程环境下需要保证它以**原子操作**执行，要保证临界区的原子操作，就需要用到线程间的互斥操作-**锁机制**，thread类库还提供了更轻量级的基于CAS操作的原子操作类。

下面用模拟3个窗口同时卖票的场景，用代码示例一下线程间的互斥操作。

## thread线程类库的互斥锁mutex

下面这段代码，启动三个线程模拟三个窗口同时卖票，总票数是100张，由于整数的- -操作不是线程安全的操作，因为多线程环境中，需要通过加互斥锁做到线程安全，代码如下示例：

[](test02mutex.cpp)

通过上面的代码可以看到，C++11的mutex和Linux平台下pthread线程库的pthread_mutex_t互斥锁使用几乎是一样的（实际上在Linux平台下mutex就是调用的pthread_mutex_t互斥锁相关的系统函数），mutex也支持trylock活锁机制，可以自己进行测试。

## thread线程类库基于CAS的原子类

实际上，上面代码中因为tickets车票数量是整数，因此它的- -操作需要在多线程环境下添加互斥操作，**但是mutex互斥锁毕竟比较重，对于系统消耗有些大**，C++11的thread类库提供了针对简单类型的原子操作类，如std::atomic_int，atomic_long，atomic_bool等，它们值的增减都是**基于CAS操作的，既保证了线程安全，效率还非常高**。

下面代码示例开启10个线程，每个线程对整数增加1000次，保证线程安全的情况下，应该加到10000次，这种情况下，可以用atomic_int来实现，代码示例如下：

[](test03CAS.cpp)

# 线程同步通信

多线程在运行过程中，各个线程都是随着OS的调度算法，占用CPU时间片来执行指令做事情，每个线程的运行完全没有顺序可言。但是在某些应用场景下，一个线程需要等待另外一个线程的运行结果，才能继续往下执行，这就需要涉及线程之间的同步通信机制。

线程间同步通信最典型的例子就是**生产者-消费者模型**，生产者线程生产出产品以后，会通知消费者线程去消费产品；如果消费者线程去消费产品，发现还没有产品生产出来，它需要通知生产者线程赶快生产产品，等生产者线程生产出产品以后，消费者线程才能继续往下执行。

C++11 线程库提供的**条件变量condition_variable**，就是Linux平台下的Condition Variable机制，**用于解决线程间的同步通信问题**，下面通过代码演示一个生产者-消费者线程模型，仔细分析代码：

[](test04PVlockDead.cpp)

# 死锁场景案例

## 多锁

[](test06lockdoublekill.cpp)

## 生产消费依赖

[](test05PVcv.cpp)

